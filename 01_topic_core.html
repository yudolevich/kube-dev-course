<!DOCTYPE html>
<html class="writer-html5" lang="ru" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Основные концепции &mdash; документация kube-dev-course </title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script src="_static/translations.js"></script>
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="Pod" href="02_topic_pod.html" />
    <link rel="prev" title="Kubernetes" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            kube-dev-course
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Поиск в документации" aria-label="Поиск в документации" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Меню навигации">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Основные концепции</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">Эволюция инфраструктуры</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">Физические сервера</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Виртуализация</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Контейнеры</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id6">Эволюция архитектуры приложений</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">Монолитная архитектура</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Микросервисная архитектура</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#kubernetes">Kubernetes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">Основные компоненты</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#control-plane">Control Plane</a></li>
<li class="toctree-l4"><a class="reference internal" href="#node">Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#api-kubernetes">API Kubernetes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">Объект</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">Структура путей</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="02_topic_pod.html">Pod</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_topic_workloads.html">Workloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_topic_netbalance.html">Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_topic_storage.html">Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_topic_accesscontrol.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="practice.html">Практика</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Меню навигации для мобильных устройств" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">kube-dev-course</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Навигация по страницам">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Основные концепции</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/01_topic_core.md.txt" rel="nofollow"> Просмотреть исходный код страницы</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>Основные концепции<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<p>Прежде чем приступить к основам Kubernetes хотелось бы кратко окунуться
в историю развития инфраструктурных решений и программной архитектуры.</p>
<section id="id2">
<h2>Эволюция инфраструктуры<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p><img alt="" src="_images/container_evolution3.svg" /></p>
<section id="id3">
<h3>Физические сервера<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<p>В давние времена приложения запускались на больших физических серверах.
Все в общем-то неплохо работало, но обнаружился ряд проблем.</p>
<ul class="simple">
<li><p>Приложения делили общие ресурсы сервера, не было возможности задать каждому приложению
определенный пул ресурсов. В связи с чем оказывалось взаимное влияние друг на друга,
иногда приводящее к неработоспособности критичных элементов. Для исключения взаимного
влияния можно было использовать другой физический сервер, что стоило довольно дорого.</p></li>
<li><p>Если приложение упиралось в потолок вычислительных ресурсов, то довольно проблематично
увеличить ресурсы физического сервера. Необходим длительный простой в работе приложения, а в
некоторых случаях это и вовсе невозможно.</p></li>
<li><p>В случае же, если необходимо было изолировать приложения на разных серверах, то
возникает проблема малой утилизации физического сервера, за которые пришлось
заплатить немалые деньги.</p></li>
</ul>
</section>
<section id="id4">
<h3>Виртуализация<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<p>Для решения данных проблем была представлена виртуализация, которая позволила запустить
на одном физическом сервере несколько виртуальных.</p>
<ul class="simple">
<li><p>Приложения в виртуальных машинах ограничены ее ресурсами и не оказывают влияния
на приложения в других виртуальных серверах.</p></li>
<li><p>Виртуальные сервера гораздо проще масштабировать(в рамках физического сервера).
Обычно достаточно перезагрузки, чтобы виртуальная машина запустилась с увеличенными
значениями ресурсов.</p></li>
<li><p>Появилась возможность уплотнить нагрузкой один физический сервер, что в общем
в лучшую сторону сказывается на стоимость инфраструктуры.</p></li>
</ul>
</section>
<section id="id5">
<h3>Контейнеры<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<p>Казалось бы проблемы решены, зачем же тогда контейнеры?
По сути своей контейнеры похожи на виртуальные машины, но работают немного по другим принципам.</p>
<ul class="simple">
<li><p>Изоляция и ограничение по ресурсам здесь происходит на уровне операционной системы.</p></li>
<li><p>Нет необходимости запускать в контейнере целую ОС, можно сразу запустить необходимое приложение
и не тратить ресурсы на вспомогательные сервисы, а также их обслуживать.</p></li>
<li><p>Накладные ресурсы на изоляцию минимальны, что позволяет запустить гораздо больше контейнеров
на одном сервере по сравнению с виртуальными машинами.</p></li>
</ul>
<p>Но основную популярность контейнеры получили с внедрением DevOps практик,
так как давали ряд дополнительных преимуществ:</p>
<ul class="simple">
<li><p>Гибкость создания и развертывания с помощью образов, что сильно упростило и ускорило
настройку приложений и среды для их работы</p></li>
<li><p>Идентичная среда для разработки, тестирования и промышленной эксплуатации, за счет
использования одного образа на всех этапах</p></li>
<li><p>Использование в CI/CD процессах: обеспечивает надежную и частую сборку, а также развертывание
с возможностью быстрого отката</p></li>
<li><p>Хорошо подходит для микросервисной архитектуры, позволяя легко создавать отдельные небольшие
слабосвязанные приложения</p></li>
</ul>
</section>
</section>
<section id="id6">
<h2>Эволюция архитектуры приложений<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h2>
<p><img alt="" src="_images/monolithvsmicro.drawio.svg" /></p>
<p>Говоря о том, как контейнеры обрели популярность, хочется также затронуть тему
микросервисной архитектуры и коротко провести сравнение с традиционной монолитной.</p>
<section id="id7">
<h3>Монолитная архитектура<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<p>Монолитные приложения состоят из сильно связанных между собой компонентов, разрабатываются и
разворачиваются как единое целое. Со стороны операционной системы они часто представляют
единый процесс(или группу), выполняя одновременно множество задач и потребляя большое количество
ресурсов.</p>
<p>Хочется сразу же отметить ряд недостатков такого подхода:</p>
<ul class="simple">
<li><p>Небольшие изменения в одном из компонентов требуют переразвертывания всего приложения</p></li>
<li><p>Требуются сервер с большим количеством ресурсов, сложнее горизонтальное масштабирование, а
вертикальное масштабирование очень быстро достигает своего предела</p></li>
<li><p>Нет возможности масштабирования только тех компонентов, которые этого требуют</p></li>
<li><p>Отказ одного из компонентов приведет к неработоспособности всего приложения</p></li>
<li><p>Единая кодовая база, сложная структура, сложность замены компонентов</p></li>
</ul>
</section>
<section id="id8">
<h3>Микросервисная архитектура<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<p>Для решения данных проблем было предложено разделить компоненты на отдельные небольшие
слабосвязанные приложения - микросервисы. Каждый микросервис работает как отдельный процесс и
взаимодействует с другими микросервисами с помощью простых заранее определенных интерфейсов(API).</p>
<p>Данный подход решает проблемы монолитной архитектуры:</p>
<ul class="simple">
<li><p>Микросервисы можно развертывать независимо, что позволяет обновлять отдельные компоненты</p></li>
<li><p>Отдельные микросервисы не потребляют большое количество ресурсов, гораздо проще горизонтальное
масштабирование</p></li>
<li><p>Можно масштабировать только те микросервисы, которым действительно нужны ресурсы</p></li>
<li><p>Отказ одного компонента затронет лишь ту часть приложения, которая от него зависит</p></li>
<li><p>Разработку можно вести разными командами, на разных языках и с разным технологическим стеком</p></li>
</ul>
</section>
</section>
<section id="kubernetes">
<h2>Kubernetes<a class="headerlink" href="#kubernetes" title="Permalink to this heading"></a></h2>
<p>Мы рассмотрели какие преимущества нам дают контейнеры, но для построения отказоустойчивой и
высоконагруженной промышленной среды этого недостаточно. Тут нам и понадобится Kubernetes,
он дарит нам такие возможности:</p>
<ul class="simple">
<li><p>Управление размещением контейнеров и их жизненным циклом на большом количестве нод</p></li>
<li><p>Масштабирование(в том числе автоматическое) и распределение нагрузки</p></li>
<li><p>Конфигурация через декларативное описание(yaml)</p></li>
</ul>
<p>и другие.</p>
<section id="id9">
<h3>Основные компоненты<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<p>Компоненты kubernetes можно разделить на компоненты панели управления(control plane) и
компоненты узла(node).</p>
<section id="control-plane">
<h4>Control Plane<a class="headerlink" href="#control-plane" title="Permalink to this heading"></a></h4>
<p>Компоненты контрольной панели отвечают за основные операции в кластере, такие как:</p>
<ul class="simple">
<li><p>Обработка операций взаимодействия с кластером(напр. создание, изменение, удаление объектов)</p></li>
<li><p>Управление размещением приложений по нодам</p></li>
<li><p>Отслеживание ресурсов и событий в кластере и их обработка</p></li>
</ul>
<p>и другие.</p>
<section id="kube-apiserver">
<h5>kube-apiserver<a class="headerlink" href="#kube-apiserver" title="Permalink to this heading"></a></h5>
<p>API сервер в kubernetes представляет из себя <a class="reference external" href="https://ru.wikipedia.org/wiki/REST">REST</a> интерфейс для взаимодействия с кластером,
он позволяет производить <a class="reference external" href="https://ru.wikipedia.org/wiki/CRUD">CRUD</a> операции над объектами kubernetes.</p>
</section>
<section id="etcd">
<h5>etcd<a class="headerlink" href="#etcd" title="Permalink to this heading"></a></h5>
<p>Распределенное и высоконадежное хранилище данных в формате «ключ-значение»,
которое используется как основное хранилище всех данных кластера в kubernetes.</p>
</section>
<section id="kube-scheduler">
<h5>kube-scheduler<a class="headerlink" href="#kube-scheduler" title="Permalink to this heading"></a></h5>
<p>Отслеживает созданные поды без привязанного узла и выбирает узел,
на котором они должны работать на основании множества факторов.</p>
</section>
<section id="kube-controller-manager">
<h5>kube-controller-manager<a class="headerlink" href="#kube-controller-manager" title="Permalink to this heading"></a></h5>
<p>В терминах kubernetes можно часто встретить понятие «контроллер».
Контроллер - это процесс, отслеживающий состояние какого-либо типа ресурса в kubernetes API и
реагирующий на изменения, пытаясь привести текущее состояние объекта к его
ожидаемому состоянию, описанному в API.</p>
<p>Контроллер менеджер содержит в себе набор контроллеров для основных типов ресурсов в kubernetes API.</p>
</section>
<section id="cloud-controller-manager">
<h5>cloud-controller-manager<a class="headerlink" href="#cloud-controller-manager" title="Permalink to this heading"></a></h5>
<p>Запускает контроллеры, которые взаимодействуют с основными облачными провайдерами.</p>
</section>
<section id="id10">
<h5>Отказоустойчивый кластер<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h5>
<p><img alt="" src="_images/ha-cluster.svg" /></p>
<p>Для компонентов контрольной панели в промышленной эксплуатации обычно выделяют отдельные ноды,
называемые мастерами(или control plane ноды). Минимальный и рекомендуемый набор состоит из трех мастеров.
Такой набор в основном обусловлен принципами работы etcd, так как основной проблемой в построении
отказоустойчивой системы является распределенное хранилище данных. В качестве алгоритма распределенного
консенсуса используется raft, <a class="reference external" href="https://thesecretlivesofdata.com/raft/">визуализацию работы которого можно посмотреть по ссылке</a>.
В raft кворум достигается при работающих N/2+1 узлах, где N - это общее количество узлов. Такое правило
необходимо для исключения <a class="reference external" href="https://postnauka.ru/longreads/73055">split-brain</a>, когда две(или более) группы нод могут из-за каких-либо проблем
в сети изолироваться друг от друга и независимо выбрать себе лидера. Таким образом при отказе одного
мастера - два других будут иметь кворум и продолжат работать. При большом же количестве мастеров
увеличится отказоустойчивость(количество нерабочих нод может быть больше при сохранении кворума), но
также увеличится нагрузка на базу, ведь каждую транзакцию необходимо отреплицировать между всеми мастерами.</p>
<p>Остальные компоненты также запущены на всех мастерах: все экземпляры apiserver параллельно могут
обрабатывать запросы и производить операции в базе, а среди экземпляров controller-manager и scheduler
лидерство занимает один из инстансов и выполняет всю работу, пока остальные ожидают.</p>
</section>
</section>
<section id="node">
<h4>Node<a class="headerlink" href="#node" title="Permalink to this heading"></a></h4>
<p>Компоненты узла работают на каждом узле, поддерживая работу подов и
среды выполнения Kubernetes.</p>
<section id="kubelet">
<h5>kubelet<a class="headerlink" href="#kubelet" title="Permalink to this heading"></a></h5>
<p>Отслеживает контейнеры, которые были назначены на ноду, на которой он запущен и
управляет их жизненным циклом.</p>
</section>
<section id="kube-proxy">
<h5>kube-proxy<a class="headerlink" href="#kube-proxy" title="Permalink to this heading"></a></h5>
<p>Занимается конфигурацией ноды для возможности маршрутизации(балансировки)
трафика к контейнерам на основании ресурса service.</p>
</section>
<section id="container-runtime">
<h5>container runtime<a class="headerlink" href="#container-runtime" title="Permalink to this heading"></a></h5>
<p>Программа, предназначенная для выполнения контейнеров, реализующая <a class="reference external" href="https://kubernetes.io/docs/concepts/architecture/cri/">CRI</a>:
Docker, containerd, CRI-O.</p>
</section>
</section>
</section>
<section id="api-kubernetes">
<h3>API Kubernetes<a class="headerlink" href="#api-kubernetes" title="Permalink to this heading"></a></h3>
<section id="id11">
<h4>Объект<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h4>
<p>Объекты Kubernetes - это сущности, которые хранятся в нем, а также отражают текущее состояние,
например:</p>
<ul class="simple">
<li><p>Конфигурация и состояние нод кластера(Node)</p></li>
<li><p>Конфигурация и состояние развертывания приложения(Deployment)</p></li>
<li><p>Конфигурация данных для приложения(ConfigMap)</p></li>
</ul>
<p>Для управления объектами существует множество инструментов как с графическим интерфейсом,
так и с консольным, либо можно взаимодействовать с API напрямую любым HTTP клиентом.</p>
<p>Пример создания объекта pod через утилиту kubectl в режиме dry-run(без создания объекта в API) и
с выводом содержимого на экран в yaml формате:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>kubectl<span class="w"> </span>run<span class="w"> </span>--image<span class="o">=</span>nginx<span class="w"> </span>nginx<span class="w"> </span>--dry-run<span class="o">=</span>client<span class="w"> </span>-o<span class="w"> </span>yaml
</pre></div>
</div>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">creationTimestamp</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">null</span>
<span class="w">  </span><span class="nt">labels</span><span class="p">:</span>
<span class="w">    </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx</span>
<span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="w">  </span><span class="nt">containers</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx</span>
<span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx</span>
<span class="w">    </span><span class="nt">resources</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{}</span>
<span class="w">  </span><span class="nt">dnsPolicy</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ClusterFirst</span>
<span class="w">  </span><span class="nt">restartPolicy</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Always</span>
<span class="nt">status</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{}</span>
</pre></div>
</div>
<p>Для любого объекта присущи такие поля как <strong>apiVersion</strong> и <strong>kind</strong> характеризующие тип объекта(ObjectType), а
также <strong>metadata</strong>, которая хранит в себе ряд метаданных(ObjectMeta), таких как:</p>
<ul class="simple">
<li><p><em>name</em> - имя объекта</p></li>
<li><p><em>namespace</em> - объекты делятся на два типа(scope): namespaced и cluster-wide, для первого типа в этом
поле указывается имя неймспейса</p></li>
<li><p><em>labels</em> - набор меток(ключ-значение), по которым можно производить фильтрацию и операции выборки</p></li>
<li><p><em>annotations</em> - набор аннотаций(ключ-значение), в которых можно сохранить дополнительную информацию</p></li>
</ul>
<p>и другие.</p>
<p>В большинстве объектов также присутствуют поля <strong>spec</strong> и <strong>status</strong>. В поле <strong>spec</strong> описывается ожидаемое
состояние объекта, а в поле <strong>status</strong> отражается состояние приведения текущего состояния к ожидаемому.</p>
</section>
<section id="id12">
<h4>Структура путей<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h4>
<p>Если обратиться к API через любой HTTP клиент без указания конкретного пути, то в ответ можно получить список
path c набором доступных путей, среди которых есть пути начинающиеся с <code class="docutils literal notranslate"><span class="pre">/api</span></code> и <code class="docutils literal notranslate"><span class="pre">/apis</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>kubectl<span class="w"> </span>get<span class="w"> </span>--raw<span class="w"> </span>/
<span class="o">{</span>
<span class="w">  </span><span class="s2">&quot;paths&quot;</span>:<span class="w"> </span><span class="o">[</span>
<span class="w">    </span><span class="s2">&quot;/.well-known/openid-configuration&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/api&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/api/v1&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/admissionregistration.k8s.io&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/admissionregistration.k8s.io/v1&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/apiextensions.k8s.io&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/apiextensions.k8s.io/v1&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/apiregistration.k8s.io&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/apiregistration.k8s.io/v1&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/apps&quot;</span>,
<span class="w">    </span><span class="s2">&quot;/apis/apps/v1&quot;</span>,
<span class="w">    </span>...
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">/api</span></code> - core группа, которая считается устаревшей, доступна по пути <code class="docutils literal notranslate"><span class="pre">/api/v1</span></code> и использует
в объектах <code class="docutils literal notranslate"><span class="pre">apiVersion:</span> <span class="pre">v1</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">/apis/$GROUP/$VERSION</span></code> - именованные группы используют в объектах <code class="docutils literal notranslate"><span class="pre">apiVersion:</span> <span class="pre">$GROUP/$VERSION</span></code></p>
<p>Далее, чтобы получить список ресурсов конкретного типа, в зависимости от того namespaced этот ресурс или
cluster-wide, можно пойти двумя путями:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/apis/$GROUP/$VERSION/$RESOURCE</span></code> - для cluster-wide
ресурсов(<code class="docutils literal notranslate"><span class="pre">/apis/apiregistration.k8s.io/v1/apiservices</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/apis/$GROUP/$VERSION/namespaces/$NAMESPACE/$RESOURCE</span></code> - для
namespaced(<code class="docutils literal notranslate"><span class="pre">/apis/apps/v1/namespaces/default/deployments</span></code>)</p></li>
</ul>
<p>Ну и для обращения к конкретному ресурсу необходимо просто указать его имя в конце пути:
<code class="docutils literal notranslate"><span class="pre">/apis/$GROUP/$VERSION/namespaces/$NAMESPACE/$RESOURCE/$NAME</span></code></p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Нижняя область">
        <a href="index.html" class="btn btn-neutral float-left" title="Kubernetes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Предыдущая</a>
        <a href="02_topic_pod.html" class="btn btn-neutral float-right" title="Pod" accesskey="n" rel="next">Следующая <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Алексей Юдолевич.</p>
  </div>

  Собрано при помощи <a href="https://www.sphinx-doc.org/">Sphinx</a> с использованием
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">темы,</a>
    предоставленной <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>